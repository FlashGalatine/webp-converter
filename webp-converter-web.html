<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebP Image Converter - Web Edition</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Preset configurations
        const BUILT_IN_PRESETS = {
            "Freestyle": null,
            "Square (1:1)": 1,
            "16:9 Landscape": 16/9,
            "9:16 Portrait": 9/16,
            "4:3 Landscape": 4/3,
            "3:4 Portrait": 3/4,
            "21:9 Ultrawide": 21/9,
            "Twitter Post": 16/9,
            "Twitter Header": 3/1,
            "Instagram Square": 1,
            "Instagram Portrait": 4/5,
            "Instagram Landscape": 1.91/1,
            "Facebook Post": 1.91/1,
            "YouTube Thumbnail": 16/9,
            "Discord Avatar": 1,
            "Pinterest Pin": 2/3
        };

        function WebPConverter() {
            // Image state
            const [image, setImage] = useState(null);
            const [imageData, setImageData] = useState(null);
            
            // Canvas state
            const [zoomLevel, setZoomLevel] = useState(1);
            const [panX, setPanX] = useState(0);
            const [panY, setPanY] = useState(0);
            
            // Crop state
            const [cropX, setCropX] = useState(0);
            const [cropY, setCropY] = useState(0);
            const [cropWidth, setCropWidth] = useState(0);
            const [cropHeight, setCropHeight] = useState(0);
            const [aspectRatio, setAspectRatio] = useState(null);
            
            // Settings state
            const [selectedPreset, setSelectedPreset] = useState("16:9 Landscape");
            const [quality, setQuality] = useState(95);
            const [lossless, setLossless] = useState(false);
            const [maxWidth, setMaxWidth] = useState('');
            const [maxHeight, setMaxHeight] = useState('');
            const [webOptimize, setWebOptimize] = useState(false);
            const [targetSize, setTargetSize] = useState('10');
            const [isOptimizing, setIsOptimizing] = useState(false);
            const [optimizingProgress, setOptimizingProgress] = useState(0);
            const [optimizingStatus, setOptimizingStatus] = useState('');
            
            // Preset state
            const [useCustomPresets, setUseCustomPresets] = useState(false);
            const [customPresets, setCustomPresets] = useState({});
            const [customPresetsRaw, setCustomPresetsRaw] = useState({});
            const [customPresetsFileName, setCustomPresetsFileName] = useState('');
            
            // Interaction state
            const [isDragging, setIsDragging] = useState(false);
            const [dragType, setDragType] = useState(null); // 'pan', 'move', 'resize-nw', etc.
            const [dragStartX, setDragStartX] = useState(0);
            const [dragStartY, setDragStartY] = useState(0);
            const [dragStartCropX, setDragStartCropX] = useState(0);
            const [dragStartCropY, setDragStartCropY] = useState(0);
            const [dragStartCropWidth, setDragStartCropWidth] = useState(0);
            const [dragStartCropHeight, setDragStartCropHeight] = useState(0);
            const [dragStartPanX, setDragStartPanX] = useState(0);
            const [dragStartPanY, setDragStartPanY] = useState(0);
            
            const canvasRef = useRef(null);
            const fileInputRef = useRef(null);
            const presetFileInputRef = useRef(null);
            const containerRef = useRef(null);
            
            // Load image
            const loadImage = (file) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        setImage(img);
                        setImageData(e.target.result);
                        
                        // Initialize crop to full image
                        const ratio = getCurrentPresets()[selectedPreset];
                        initializeCrop(img.width, img.height, ratio);
                        
                        // Auto zoom to fit if image is large
                        setTimeout(() => {
                            const canvas = canvasRef.current;
                            if (canvas && (img.width > canvas.width * 0.9 || img.height > canvas.height * 0.9)) {
                                handleZoomToFit();
                            }
                        }, 100);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            };
            
            // Get current preset collection (built-in or custom)
            const getCurrentPresets = () => {
                return useCustomPresets ? customPresets : BUILT_IN_PRESETS;
            };
            
            // Load custom presets from JSON file
            const loadCustomPresets = (file) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const jsonData = JSON.parse(e.target.result);
                        setCustomPresetsRaw(jsonData);
                        
                        // Convert JSON presets to internal format
                        const converted = {};
                        for (const [name, config] of Object.entries(jsonData)) {
                            if (config['crop-ratio']) {
                                converted[name] = config['crop-ratio'];
                            } else {
                                converted[name] = null; // Freestyle
                            }
                        }
                        
                        setCustomPresets(converted);
                        setCustomPresetsFileName(file.name);
                        setUseCustomPresets(true);
                        
                        // Reset to first preset
                        const firstPreset = Object.keys(converted)[0];
                        setSelectedPreset(firstPreset);
                        
                    } catch (error) {
                        alert(`Error loading preset file: ${error.message}`);
                    }
                };
                reader.readAsText(file);
            };
            
            // Apply preset-specific settings (from custom presets)
            const applyPresetSettings = (presetName) => {
                if (useCustomPresets && customPresetsRaw[presetName]) {
                    const config = customPresetsRaw[presetName];
                    
                    // Apply max dimensions
                    if (config['max-width']) {
                        setMaxWidth(config['max-width'].toString());
                    } else {
                        setMaxWidth('');
                    }
                    
                    if (config['max-height']) {
                        setMaxHeight(config['max-height'].toString());
                    } else {
                        setMaxHeight('');
                    }
                    
                    // Apply target file size
                    if (config['max-filesize']) {
                        const size = config['max-filesize'];
                        const unit = config['max-filesize-unit'] || 'MB';
                        
                        // Convert to MB
                        let sizeInMB = size;
                        if (unit === 'KB') {
                            sizeInMB = size / 1024;
                        } else if (unit === 'GB') {
                            sizeInMB = size * 1024;
                        }
                        
                        setTargetSize(sizeInMB.toString());
                        setWebOptimize(true);
                    }
                }
            };
            
            // Initialize crop based on aspect ratio
            const initializeCrop = (imgWidth, imgHeight, ratio) => {
                if (!ratio) {
                    setCropX(0);
                    setCropY(0);
                    setCropWidth(imgWidth);
                    setCropHeight(imgHeight);
                } else {
                    const imgRatio = imgWidth / imgHeight;
                    let w, h;
                    
                    if (ratio > imgRatio) {
                        w = imgWidth;
                        h = imgWidth / ratio;
                    } else {
                        h = imgHeight;
                        w = imgHeight * ratio;
                    }
                    
                    setCropX((imgWidth - w) / 2);
                    setCropY((imgHeight - h) / 2);
                    setCropWidth(w);
                    setCropHeight(h);
                }
            };
            
            // Handle preset change
            useEffect(() => {
                const currentPresets = getCurrentPresets();
                const ratio = currentPresets[selectedPreset];
                setAspectRatio(ratio);
                if (image) {
                    initializeCrop(image.width, image.height, ratio);
                }
                
                // Apply preset-specific settings (from custom presets)
                applyPresetSettings(selectedPreset);
            }, [selectedPreset, useCustomPresets]);
            
            // Draw on canvas
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !image) return;
                
                const ctx = canvas.getContext('2d');
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                
                // Clear canvas
                ctx.fillStyle = '#2b2b2b';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                
                // Calculate display dimensions
                const displayWidth = image.width * zoomLevel;
                const displayHeight = image.height * zoomLevel;
                
                // Calculate image position (centered + pan)
                const imgX = (canvasWidth - displayWidth) / 2 + panX;
                const imgY = (canvasHeight - displayHeight) / 2 + panY;
                
                // Draw image
                ctx.drawImage(image, imgX, imgY, displayWidth, displayHeight);
                
                // Draw crop overlay if aspect ratio is set
                if (aspectRatio !== null) {
                    // Calculate crop coordinates in display space
                    const cropDisplayX = imgX + cropX * zoomLevel;
                    const cropDisplayY = imgY + cropY * zoomLevel;
                    const cropDisplayWidth = cropWidth * zoomLevel;
                    const cropDisplayHeight = cropHeight * zoomLevel;
                    
                    // Draw darkened overlay outside crop
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(0, 0, canvasWidth, cropDisplayY); // Top
                    ctx.fillRect(0, cropDisplayY, cropDisplayX, cropDisplayHeight); // Left
                    ctx.fillRect(cropDisplayX + cropDisplayWidth, cropDisplayY, canvasWidth, cropDisplayHeight); // Right
                    ctx.fillRect(0, cropDisplayY + cropDisplayHeight, canvasWidth, canvasHeight); // Bottom
                    
                    // Draw crop border
                    ctx.strokeStyle = '#fbbf24';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(cropDisplayX, cropDisplayY, cropDisplayWidth, cropDisplayHeight);
                    
                    // Draw rule of thirds grid
                    ctx.strokeStyle = 'rgba(251, 191, 36, 0.5)';
                    ctx.lineWidth = 1;
                    
                    // Vertical lines
                    const third1X = cropDisplayX + cropDisplayWidth / 3;
                    const third2X = cropDisplayX + (2 * cropDisplayWidth) / 3;
                    ctx.beginPath();
                    ctx.moveTo(third1X, cropDisplayY);
                    ctx.lineTo(third1X, cropDisplayY + cropDisplayHeight);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(third2X, cropDisplayY);
                    ctx.lineTo(third2X, cropDisplayY + cropDisplayHeight);
                    ctx.stroke();
                    
                    // Horizontal lines
                    const third1Y = cropDisplayY + cropDisplayHeight / 3;
                    const third2Y = cropDisplayY + (2 * cropDisplayHeight) / 3;
                    ctx.beginPath();
                    ctx.moveTo(cropDisplayX, third1Y);
                    ctx.lineTo(cropDisplayX + cropDisplayWidth, third1Y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(cropDisplayX, third2Y);
                    ctx.lineTo(cropDisplayX + cropDisplayWidth, third2Y);
                    ctx.stroke();
                    
                    // Draw resize handles
                    const handleSize = 10;
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    
                    const handles = [
                        { x: cropDisplayX, y: cropDisplayY }, // NW
                        { x: cropDisplayX + cropDisplayWidth / 2, y: cropDisplayY }, // N
                        { x: cropDisplayX + cropDisplayWidth, y: cropDisplayY }, // NE
                        { x: cropDisplayX + cropDisplayWidth, y: cropDisplayY + cropDisplayHeight / 2 }, // E
                        { x: cropDisplayX + cropDisplayWidth, y: cropDisplayY + cropDisplayHeight }, // SE
                        { x: cropDisplayX + cropDisplayWidth / 2, y: cropDisplayY + cropDisplayHeight }, // S
                        { x: cropDisplayX, y: cropDisplayY + cropDisplayHeight }, // SW
                        { x: cropDisplayX, y: cropDisplayY + cropDisplayHeight / 2 } // W
                    ];
                    
                    handles.forEach(handle => {
                        ctx.fillRect(handle.x - handleSize / 2, handle.y - handleSize / 2, handleSize, handleSize);
                        ctx.strokeRect(handle.x - handleSize / 2, handle.y - handleSize / 2, handleSize, handleSize);
                    });
                }
            }, [image, zoomLevel, panX, panY, cropX, cropY, cropWidth, cropHeight, aspectRatio]);
            
            // Get cursor position relative to canvas
            const getCursorPos = (e) => {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            };
            
            // Convert canvas coordinates to image coordinates
            const canvasToImage = (canvasX, canvasY) => {
                const canvas = canvasRef.current;
                const displayWidth = image.width * zoomLevel;
                const displayHeight = image.height * zoomLevel;
                const imgX = (canvas.width - displayWidth) / 2 + panX;
                const imgY = (canvas.height - displayHeight) / 2 + panY;
                
                return {
                    x: (canvasX - imgX) / zoomLevel,
                    y: (canvasY - imgY) / zoomLevel
                };
            };
            
            // Detect which handle is being hovered/clicked
            const detectHandle = (canvasX, canvasY) => {
                if (!image || aspectRatio === null) return null;
                
                const canvas = canvasRef.current;
                const displayWidth = image.width * zoomLevel;
                const displayHeight = image.height * zoomLevel;
                const imgX = (canvas.width - displayWidth) / 2 + panX;
                const imgY = (canvas.height - displayHeight) / 2 + panY;
                
                const cropDisplayX = imgX + cropX * zoomLevel;
                const cropDisplayY = imgY + cropY * zoomLevel;
                const cropDisplayWidth = cropWidth * zoomLevel;
                const cropDisplayHeight = cropHeight * zoomLevel;
                
                const handleSize = 10;
                const tolerance = 5;
                
                const handles = {
                    'nw': { x: cropDisplayX, y: cropDisplayY },
                    'n': { x: cropDisplayX + cropDisplayWidth / 2, y: cropDisplayY },
                    'ne': { x: cropDisplayX + cropDisplayWidth, y: cropDisplayY },
                    'e': { x: cropDisplayX + cropDisplayWidth, y: cropDisplayY + cropDisplayHeight / 2 },
                    'se': { x: cropDisplayX + cropDisplayWidth, y: cropDisplayY + cropDisplayHeight },
                    's': { x: cropDisplayX + cropDisplayWidth / 2, y: cropDisplayY + cropDisplayHeight },
                    'sw': { x: cropDisplayX, y: cropDisplayY + cropDisplayHeight },
                    'w': { x: cropDisplayX, y: cropDisplayY + cropDisplayHeight / 2 }
                };
                
                for (const [key, handle] of Object.entries(handles)) {
                    if (Math.abs(canvasX - handle.x) <= handleSize / 2 + tolerance &&
                        Math.abs(canvasY - handle.y) <= handleSize / 2 + tolerance) {
                        return key;
                    }
                }
                
                return null;
            };
            
            // Check if cursor is inside crop rectangle
            const isInsideCrop = (canvasX, canvasY) => {
                if (!image) return false;
                
                const canvas = canvasRef.current;
                const displayWidth = image.width * zoomLevel;
                const displayHeight = image.height * zoomLevel;
                const imgX = (canvas.width - displayWidth) / 2 + panX;
                const imgY = (canvas.height - displayHeight) / 2 + panY;
                
                const cropDisplayX = imgX + cropX * zoomLevel;
                const cropDisplayY = imgY + cropY * zoomLevel;
                const cropDisplayWidth = cropWidth * zoomLevel;
                const cropDisplayHeight = cropHeight * zoomLevel;
                
                return canvasX >= cropDisplayX && canvasX <= cropDisplayX + cropDisplayWidth &&
                       canvasY >= cropDisplayY && canvasY <= cropDisplayY + cropDisplayHeight;
            };
            
            // Mouse down handler
            const handleMouseDown = (e) => {
                if (!image) return;
                
                const pos = getCursorPos(e);
                const handle = detectHandle(pos.x, pos.y);
                
                if (handle) {
                    setDragType(`resize-${handle}`);
                    setDragStartCropX(cropX);
                    setDragStartCropY(cropY);
                    setDragStartCropWidth(cropWidth);
                    setDragStartCropHeight(cropHeight);
                } else if (isInsideCrop(pos.x, pos.y)) {
                    setDragType('move');
                    setDragStartCropX(cropX);
                    setDragStartCropY(cropY);
                } else {
                    setDragType('pan');
                    setDragStartPanX(panX);
                    setDragStartPanY(panY);
                }
                
                setIsDragging(true);
                setDragStartX(pos.x);
                setDragStartY(pos.y);
            };
            
            // Mouse move handler
            const handleMouseMove = (e) => {
                if (!isDragging || !image) return;
                
                const pos = getCursorPos(e);
                const dx = pos.x - dragStartX;
                const dy = pos.y - dragStartY;
                
                if (dragType === 'pan') {
                    setPanX(dragStartPanX + dx);
                    setPanY(dragStartPanY + dy);
                } else if (dragType === 'move') {
                    const dxImg = dx / zoomLevel;
                    const dyImg = dy / zoomLevel;
                    
                    let newX = dragStartCropX + dxImg;
                    let newY = dragStartCropY + dyImg;
                    
                    // Constrain to image bounds
                    newX = Math.max(0, Math.min(newX, image.width - cropWidth));
                    newY = Math.max(0, Math.min(newY, image.height - cropHeight));
                    
                    setCropX(newX);
                    setCropY(newY);
                } else if (dragType.startsWith('resize-')) {
                    const direction = dragType.split('-')[1];
                    const dxImg = dx / zoomLevel;
                    const dyImg = dy / zoomLevel;
                    
                    let newX = dragStartCropX;
                    let newY = dragStartCropY;
                    let newWidth = dragStartCropWidth;
                    let newHeight = dragStartCropHeight;
                    
                    // Handle resize based on direction
                    if (direction.includes('w')) {
                        newX = dragStartCropX + dxImg;
                        newWidth = dragStartCropWidth - dxImg;
                    }
                    if (direction.includes('e')) {
                        newWidth = dragStartCropWidth + dxImg;
                    }
                    if (direction.includes('n')) {
                        newY = dragStartCropY + dyImg;
                        newHeight = dragStartCropHeight - dyImg;
                    }
                    if (direction.includes('s')) {
                        newHeight = dragStartCropHeight + dyImg;
                    }
                    
                    // Maintain aspect ratio if set
                    if (aspectRatio) {
                        if (direction.includes('e') || direction.includes('w')) {
                            newHeight = newWidth / aspectRatio;
                            if (direction.includes('n')) {
                                newY = dragStartCropY + dragStartCropHeight - newHeight;
                            }
                        } else {
                            newWidth = newHeight * aspectRatio;
                            if (direction.includes('w')) {
                                newX = dragStartCropX + dragStartCropWidth - newWidth;
                            }
                        }
                    }
                    
                    // Constrain to image bounds
                    if (newX < 0) {
                        newWidth += newX;
                        newX = 0;
                    }
                    if (newY < 0) {
                        newHeight += newY;
                        newY = 0;
                    }
                    if (newX + newWidth > image.width) {
                        newWidth = image.width - newX;
                    }
                    if (newY + newHeight > image.height) {
                        newHeight = image.height - newY;
                    }
                    
                    // Minimum size
                    if (newWidth > 10 && newHeight > 10) {
                        setCropX(newX);
                        setCropY(newY);
                        setCropWidth(newWidth);
                        setCropHeight(newHeight);
                    }
                }
            };
            
            // Mouse up handler
            const handleMouseUp = () => {
                setIsDragging(false);
                setDragType(null);
            };
            
            // Wheel handler for zoom
            const handleWheel = (e) => {
                e.preventDefault();
                if (!image) return;
                
                const delta = e.deltaY;
                const zoomFactor = delta > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(0.1, Math.min(zoomLevel * zoomFactor, 10));
                setZoomLevel(newZoom);
            };
            
            // Zoom controls
            const handleZoomIn = () => {
                setZoomLevel(Math.min(zoomLevel * 1.1, 10));
            };
            
            const handleZoomOut = () => {
                setZoomLevel(Math.max(zoomLevel * 0.9, 0.1));
            };
            
            const handleZoomReset = () => {
                setZoomLevel(1);
                setPanX(0);
                setPanY(0);
            };
            
            const handleZoomToFit = () => {
                if (!image) return;
                
                const canvas = canvasRef.current;
                const padding = 40;
                const zoomX = (canvas.width - padding) / image.width;
                const zoomY = (canvas.height - padding) / image.height;
                const newZoom = Math.min(zoomX, zoomY);
                
                setZoomLevel(Math.max(0.1, Math.min(newZoom, 10)));
                setPanX(0);
                setPanY(0);
            };
            
            // File upload handlers
            const handleFileSelect = (e) => {
                const file = e.target.files[0];
                if (file) {
                    loadImage(file);
                }
            };
            
            const handleDrop = (e) => {
                e.preventDefault();
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    loadImage(file);
                }
            };
            
            const handleDragOver = (e) => {
                e.preventDefault();
            };
            
            // Convert and download
            const handleConvert = async () => {
                if (!image) return;
                
                setIsOptimizing(true);
                setOptimizingProgress(0);
                setOptimizingStatus('Cropping image...');
                
                // Create temporary canvas for cropping
                const tempCanvas = document.createElement('canvas');
                let finalWidth = cropWidth;
                let finalHeight = cropHeight;
                
                // Apply max dimensions if specified
                const maxW = maxWidth ? parseInt(maxWidth) : null;
                const maxH = maxHeight ? parseInt(maxHeight) : null;
                
                if (maxW && finalWidth > maxW) {
                    const ratio = maxW / finalWidth;
                    finalWidth = maxW;
                    finalHeight = finalHeight * ratio;
                }
                
                if (maxH && finalHeight > maxH) {
                    const ratio = maxH / finalHeight;
                    finalHeight = maxH;
                    finalWidth = finalWidth * ratio;
                }
                
                tempCanvas.width = Math.round(finalWidth);
                tempCanvas.height = Math.round(finalHeight);
                const ctx = tempCanvas.getContext('2d');
                
                // Draw cropped and resized image
                ctx.drawImage(
                    image,
                    cropX, cropY, cropWidth, cropHeight,
                    0, 0, finalWidth, finalHeight
                );
                
                // Determine quality and optimization
                let finalQuality = quality;
                let usedLossless = lossless;
                
                // Web optimization
                if (webOptimize && !lossless) {
                    setOptimizingStatus('Testing lossless compression...');
                    setOptimizingProgress(0);
                    
                    const targetSizeBytes = parseFloat(targetSize) * 1024 * 1024;
                    
                    // Try lossless first
                    const losslessBlob = await new Promise(resolve => {
                        tempCanvas.toBlob(resolve, 'image/webp', 1);
                    });
                    
                    if (losslessBlob.size <= targetSizeBytes) {
                        setOptimizingStatus('âœ“ Lossless fits within target!');
                        setOptimizingProgress(100);
                        usedLossless = true;
                        
                        // Download
                        await new Promise(resolve => setTimeout(resolve, 800));
                        downloadBlob(losslessBlob, tempCanvas.width, tempCanvas.height, 'LL');
                        setIsOptimizing(false);
                        return;
                    }
                    
                    // Try quality levels from 100 down to 1
                    setOptimizingStatus('Finding optimal quality level...');
                    let foundQuality = null;
                    
                    for (let q = 100; q >= 1; q--) {
                        setOptimizingProgress(((100 - q) / 100) * 100);
                        setOptimizingStatus(`Testing quality ${q}... (${100 - q + 1}/100)`);
                        
                        const blob = await new Promise(resolve => {
                            tempCanvas.toBlob(resolve, 'image/webp', q / 100);
                        });
                        
                        if (blob.size <= targetSizeBytes) {
                            foundQuality = q;
                            setOptimizingStatus(`âœ“ Quality ${q} achieves ${(blob.size / 1024 / 1024).toFixed(2)}MB`);
                            setOptimizingProgress(100);
                            
                            // Download
                            await new Promise(resolve => setTimeout(resolve, 1000));
                            downloadBlob(blob, tempCanvas.width, tempCanvas.height, q);
                            setIsOptimizing(false);
                            return;
                        }
                    }
                    
                    // If we get here, even quality 1 is too large
                    setOptimizingStatus('âš  Could not meet target size. Using quality 1.');
                    finalQuality = 1;
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
                
                // Standard conversion
                setOptimizingStatus('Converting to WebP...');
                const mimeType = 'image/webp';
                const qualityValue = usedLossless ? 1 : finalQuality / 100;
                
                tempCanvas.toBlob((blob) => {
                    downloadBlob(blob, tempCanvas.width, tempCanvas.height, usedLossless ? 'LL' : finalQuality);
                    setIsOptimizing(false);
                }, mimeType, qualityValue);
            };
            
            // Helper function to download blob
            const downloadBlob = (blob, width, height, qualityValue) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const date = new Date().toISOString().split('T')[0];
                const resolution = `${Math.round(width)}x${Math.round(height)}px`;
                const qualityStr = qualityValue === 'LL' ? 'qLL' : `q${qualityValue}`;
                a.download = `image-${date}-${resolution}-${qualityStr}.webp`;
                a.href = url;
                a.click();
                URL.revokeObjectURL(url);
            };
            
            // Keyboard shortcuts
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === '=' || e.key === '+') {
                            e.preventDefault();
                            handleZoomIn();
                        } else if (e.key === '-') {
                            e.preventDefault();
                            handleZoomOut();
                        } else if (e.key === '0') {
                            e.preventDefault();
                            handleZoomReset();
                        } else if (e.key === 'f' || e.key === 'F') {
                            e.preventDefault();
                            handleZoomToFit();
                        }
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [image, zoomLevel]);
            
            return (
                <div className="flex h-screen bg-gray-900 text-gray-100">
                    {/* Left Panel - Controls */}
                    <div className="w-80 bg-gray-800 p-4 overflow-y-auto">
                        <h1 className="text-2xl font-bold mb-6 text-amber-400">WebP Converter</h1>
                        
                        {/* File Selection */}
                        <div className="mb-6">
                            <h2 className="text-sm font-semibold mb-2 text-gray-300">Load Image</h2>
                            <input
                                ref={fileInputRef}
                                type="file"
                                accept="image/*"
                                onChange={handleFileSelect}
                                className="hidden"
                            />
                            <button
                                onClick={() => fileInputRef.current.click()}
                                className="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded"
                            >
                                Select Image
                            </button>
                            <p className="text-xs text-gray-400 mt-2">Or drag and drop onto canvas</p>
                        </div>
                        
                        {/* Custom Preset Loader */}
                        <div className="mb-6">
                            <h2 className="text-sm font-semibold mb-2 text-gray-300">Preset Source</h2>
                            <input
                                ref={presetFileInputRef}
                                type="file"
                                accept=".json"
                                onChange={(e) => {
                                    if (e.target.files && e.target.files[0]) {
                                        loadCustomPresets(e.target.files[0]);
                                    }
                                }}
                                className="hidden"
                            />
                            
                            {!useCustomPresets ? (
                                <div>
                                    <button
                                        onClick={() => presetFileInputRef.current.click()}
                                        className="w-full bg-purple-600 hover:bg-purple-700 text-white py-2 px-4 rounded"
                                    >
                                        Load Custom Presets
                                    </button>
                                    <p className="text-xs text-gray-400 mt-2">Using built-in presets</p>
                                </div>
                            ) : (
                                <div>
                                    <div className="bg-gray-700 p-3 rounded mb-2">
                                        <p className="text-xs text-amber-400 font-semibold mb-1">Custom Presets Loaded</p>
                                        <p className="text-xs text-gray-300 break-all">{customPresetsFileName}</p>
                                        <p className="text-xs text-gray-400 mt-1">{Object.keys(customPresets).length} presets available</p>
                                    </div>
                                    <div className="grid grid-cols-2 gap-2">
                                        <button
                                            onClick={() => presetFileInputRef.current.click()}
                                            className="bg-purple-600 hover:bg-purple-700 text-white py-1.5 px-3 rounded text-sm"
                                        >
                                            Load Different
                                        </button>
                                        <button
                                            onClick={() => {
                                                setUseCustomPresets(false);
                                                setSelectedPreset("16:9 Landscape");
                                                setCustomPresets({});
                                                setCustomPresetsRaw({});
                                                setCustomPresetsFileName('');
                                            }}
                                            className="bg-gray-600 hover:bg-gray-500 text-white py-1.5 px-3 rounded text-sm"
                                        >
                                            Use Built-in
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                        
                        {/* Preset Selection */}
                        <div className="mb-6">
                            <h2 className="text-sm font-semibold mb-2 text-gray-300">Crop Preset</h2>
                            <select
                                value={selectedPreset}
                                onChange={(e) => setSelectedPreset(e.target.value)}
                                className="w-full bg-gray-700 text-white py-2 px-3 rounded"
                            >
                                {Object.keys(getCurrentPresets()).map(preset => (
                                    <option key={preset} value={preset}>{preset}</option>
                                ))}
                            </select>
                            {useCustomPresets && customPresetsRaw[selectedPreset] && (
                                <div className="mt-2 text-xs text-amber-400 bg-gray-700 p-2 rounded">
                                    <p className="font-semibold mb-1">ðŸ“‹ Preset includes:</p>
                                    {customPresetsRaw[selectedPreset]['max-width'] && (
                                        <p>â€¢ Max width: {customPresetsRaw[selectedPreset]['max-width']}px</p>
                                    )}
                                    {customPresetsRaw[selectedPreset]['max-height'] && (
                                        <p>â€¢ Max height: {customPresetsRaw[selectedPreset]['max-height']}px</p>
                                    )}
                                    {customPresetsRaw[selectedPreset]['max-filesize'] && (
                                        <p>â€¢ Target size: {customPresetsRaw[selectedPreset]['max-filesize']}{customPresetsRaw[selectedPreset]['max-filesize-unit'] || 'MB'}</p>
                                    )}
                                </div>
                            )}
                        </div>
                        
                        {/* WebP Options */}
                        <div className="mb-6">
                            <h2 className="text-sm font-semibold mb-3 text-gray-300">WebP Options</h2>
                            
                            <div className="mb-3">
                                <label className="flex items-center">
                                    <input
                                        type="radio"
                                        checked={!lossless}
                                        onChange={() => setLossless(false)}
                                        className="mr-2"
                                    />
                                    <span>Lossy</span>
                                </label>
                                <label className="flex items-center">
                                    <input
                                        type="radio"
                                        checked={lossless}
                                        onChange={() => setLossless(true)}
                                        className="mr-2"
                                    />
                                    <span>Lossless</span>
                                </label>
                            </div>
                            
                            {!lossless && (
                                <div>
                                    <div className="flex justify-between mb-1">
                                        <span className="text-sm">Quality:</span>
                                        <span className="text-sm font-semibold text-amber-400">{quality}%</span>
                                    </div>
                                    <input
                                        type="range"
                                        min="1"
                                        max="100"
                                        value={quality}
                                        onChange={(e) => setQuality(parseInt(e.target.value))}
                                        className="w-full"
                                    />
                                </div>
                            )}
                            
                            {/* Web Optimization */}
                            <div className="mt-4">
                                <label className="flex items-center mb-2">
                                    <input
                                        type="checkbox"
                                        checked={webOptimize}
                                        onChange={(e) => setWebOptimize(e.target.checked)}
                                        className="mr-2"
                                    />
                                    <span>Optimize for Web</span>
                                </label>
                                
                                {webOptimize && (
                                    <div className="flex items-center gap-2 ml-6">
                                        <label className="text-sm">Target Size:</label>
                                        <input
                                            type="number"
                                            value={targetSize}
                                            onChange={(e) => setTargetSize(e.target.value)}
                                            className="w-16 bg-gray-700 text-white py-1 px-2 rounded"
                                            min="0.1"
                                            step="0.5"
                                        />
                                        <span className="text-sm">MB</span>
                                    </div>
                                )}
                            </div>
                        </div>
                        
                        {/* Max Dimensions */}
                        <div className="mb-6">
                            <h2 className="text-sm font-semibold mb-2 text-gray-300">Max Dimensions (optional)</h2>
                            <div className="space-y-2">
                                <div className="flex items-center gap-2">
                                    <label className="text-sm w-20">Max Width:</label>
                                    <input
                                        type="number"
                                        value={maxWidth}
                                        onChange={(e) => setMaxWidth(e.target.value)}
                                        placeholder="pixels"
                                        className="flex-1 bg-gray-700 text-white py-1 px-2 rounded"
                                    />
                                </div>
                                <div className="flex items-center gap-2">
                                    <label className="text-sm w-20">Max Height:</label>
                                    <input
                                        type="number"
                                        value={maxHeight}
                                        onChange={(e) => setMaxHeight(e.target.value)}
                                        placeholder="pixels"
                                        className="flex-1 bg-gray-700 text-white py-1 px-2 rounded"
                                    />
                                </div>
                            </div>
                        </div>
                        
                        {/* Zoom Controls */}
                        <div className="mb-6">
                            <h2 className="text-sm font-semibold mb-3 text-gray-300">Zoom Controls</h2>
                            
                            <button
                                onClick={handleZoomToFit}
                                className="w-full bg-amber-600 hover:bg-amber-700 text-white py-2 px-4 rounded mb-2"
                            >
                                Zoom to Fit
                            </button>
                            
                            <div className="grid grid-cols-3 gap-2">
                                <button
                                    onClick={handleZoomIn}
                                    className="bg-gray-700 hover:bg-gray-600 text-white py-2 px-4 rounded"
                                >
                                    Zoom In
                                </button>
                                <button
                                    onClick={handleZoomReset}
                                    className="bg-gray-700 hover:bg-gray-600 text-white py-2 px-4 rounded"
                                >
                                    Reset
                                </button>
                                <button
                                    onClick={handleZoomOut}
                                    className="bg-gray-700 hover:bg-gray-600 text-white py-2 px-4 rounded"
                                >
                                    Zoom Out
                                </button>
                            </div>
                            
                            <p className="text-xs text-gray-400 mt-2">
                                Ctrl+F (fit) â€¢ Ctrl+0 (reset) â€¢ Wheel (zoom)
                            </p>
                        </div>
                        
                        {/* Info */}
                        {image && (
                            <div className="mb-6 text-xs text-gray-400">
                                <div>Image: {image.width} Ã— {image.height}px</div>
                                <div>Crop: {Math.round(cropWidth)} Ã— {Math.round(cropHeight)}px</div>
                                {(maxWidth || maxHeight) && (() => {
                                    let finalW = cropWidth;
                                    let finalH = cropHeight;
                                    const maxW = maxWidth ? parseInt(maxWidth) : null;
                                    const maxH = maxHeight ? parseInt(maxHeight) : null;
                                    
                                    if (maxW && finalW > maxW) {
                                        const ratio = maxW / finalW;
                                        finalW = maxW;
                                        finalH = finalH * ratio;
                                    }
                                    if (maxH && finalH > maxH) {
                                        const ratio = maxH / finalH;
                                        finalH = maxH;
                                        finalW = finalW * ratio;
                                    }
                                    
                                    return <div className="text-amber-400">Output: {Math.round(finalW)} Ã— {Math.round(finalH)}px</div>;
                                })()}
                                <div>Zoom: {(zoomLevel * 100).toFixed(0)}%</div>
                            </div>
                        )}
                        
                        {/* Convert Button */}
                        <button
                            onClick={handleConvert}
                            disabled={!image || isOptimizing}
                            className="w-full bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white py-3 px-4 rounded font-semibold"
                        >
                            {isOptimizing ? 'Converting...' : 'Convert & Download'}
                        </button>
                        
                        {/* Optimization Progress */}
                        {isOptimizing && (
                            <div className="mt-4">
                                <div className="text-sm text-gray-300 mb-2">{optimizingStatus}</div>
                                <div className="w-full bg-gray-700 rounded-full h-2">
                                    <div 
                                        className="bg-amber-400 h-2 rounded-full transition-all duration-300"
                                        style={{ width: `${optimizingProgress}%` }}
                                    ></div>
                                </div>
                            </div>
                        )}
                    </div>
                    
                    {/* Right Panel - Canvas */}
                    <div 
                        ref={containerRef}
                        className="flex-1 flex items-center justify-center bg-gray-900"
                        onDrop={handleDrop}
                        onDragOver={handleDragOver}
                    >
                        {!image ? (
                            <div className="text-center text-gray-500">
                                <svg className="w-24 h-24 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                </svg>
                                <p className="text-xl mb-2">No image loaded</p>
                                <p className="text-sm">Click "Select Image" or drag & drop here</p>
                            </div>
                        ) : (
                            <canvas
                                ref={canvasRef}
                                width={800}
                                height={600}
                                onMouseDown={handleMouseDown}
                                onMouseMove={handleMouseMove}
                                onMouseUp={handleMouseUp}
                                onMouseLeave={handleMouseUp}
                                onWheel={handleWheel}
                                className="border-2 border-gray-700 cursor-move"
                                style={{ maxWidth: '100%', maxHeight: '100%' }}
                            />
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<WebPConverter />, document.getElementById('root'));
    </script>
</body>
</html>
